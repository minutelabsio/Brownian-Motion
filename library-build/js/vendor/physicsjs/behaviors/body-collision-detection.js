/**
 * PhysicsJS v1.0.0-rc1 - 2014-04-13
 * A modular, extendable, and easy-to-use physics engine for javascript
 * http://wellcaffeinated.net/PhysicsJS
 *
 * Copyright (c) 2014 Jasper Palfree <jasper@wellcaffeinated.net>
 * Licensed MIT
 */

(function(e,t){typeof define=="function"&&define.amd?define(["physicsjs"],t):typeof exports=="object"?module.exports=t.apply(e,["physicsjs"].map(require)):t.call(e,e.Physics)})(this,function(e){return e.behavior("body-collision-detection",function(t){var n=function(n,r){var i;return i=function(t){var s=e.scratchpad(),o=s.transform().setTranslation(n.state.pos).setRotation(n.state.angular.pos),u=s.transform().setTranslation(r.state.pos).setRotation(r.state.angular.pos),a=s.vector(),f=s.vector(),l=i.marginA,c=i.marginB;return i.useCore?(a=n.geometry.getFarthestCorePoint(t.rotateInv(o),a,l).transform(o),f=r.geometry.getFarthestCorePoint(t.rotate(o).rotateInv(u).negate(),f,c).transform(u)):(a=n.geometry.getFarthestHullPoint(t.rotateInv(o),a,l).transform(o),f=r.geometry.getFarthestHullPoint(t.rotate(o).rotateInv(u).negate(),f,c).transform(u)),t.negate().rotate(u),s.done({a:a.values(),b:f.values(),pt:a.vsub(f).values()})},i.useCore=!1,i.margin=0,i},r=function(r,i){var s=e.scratchpad(),o=s.vector(),u=s.vector(),a,f,l,c=!1,h=r.aabb(),p=Math.min(h.hw,h.hh),d=i.aabb(),v=Math.min(d.hw,d.hh);l=n(r,i),o.clone(r.state.pos).vsub(i.state.pos),f=e.gjk(l,o,!0);if(f.overlap){c={bodyA:r,bodyB:i},l.useCore=!0,l.marginA=0,l.marginB=0;while(f.overlap&&(l.marginA<p||l.marginB<v))l.marginA<p&&(l.marginA+=1),l.marginB<v&&(l.marginB+=1),f=e.gjk(l,o);if(f.overlap||f.maxIterationsReached)return s.done(!1);a=Math.max(0,l.marginA+l.marginB-f.distance),c.overlap=a,c.norm=o.clone(f.closest.b).vsub(u.clone(f.closest.a)).normalize().values(),c.mtv=o.mult(a).values(),c.pos=o.clone(c.norm).mult(l.margin).vadd(u.clone(f.closest.a)).vsub(r.state.pos).values()}return s.done(c)},i=function(n,r){var i=e.scratchpad(),s=i.vector(),o=i.vector(),u,a=!1;return s.clone(r.state.pos).vsub(n.state.pos),u=s.norm()-(n.geometry.radius+r.geometry.radius),s.equals(e.vector.zero)&&s.set(1,0),u<=0&&(a={bodyA:n,bodyB:r,norm:s.normalize().values(),mtv:s.mult(-u).values(),pos:s.normalize().mult(n.geometry.radius).values(),overlap:-u}),i.done(a)},s=function(t,n){return t.treatment!=="static"&&t.treatment!=="kinematic"||n.treatment!=="static"&&n.treatment!=="kinematic"?t.geometry.name==="circle"&&n.geometry.name==="circle"?i(t,n):r(t,n):!1},o={check:"collisions:candidates",channel:"collisions:detected"};return{init:function(e){t.init.call(this),this.options.defaults(o),this.options(e)},connect:function(e){this.options.check===!0?e.on("integrate:velocities",this.checkAll,this):e.on(this.options.check,this.check,this)},disconnect:function(e){this.options.check===!0?e.off("integrate:velocities",this.checkAll):e.off(this.options.check,this.check)},check:function(t){var n=t.candidates,r,i=this.getTargets(),o=[],u;for(var a=0,f=n.length;a<f;++a){r=n[a];if(i===this._world._bodies||e.util.indexOf(i,r.bodyA)>-1&&e.util.indexOf(i,r.bodyB)>-1)u=s(r.bodyA,r.bodyB),u&&o.push(u)}o.length&&this._world.emit(this.options.channel,{collisions:o})},checkAll:function(e){var t=this.getTargets(),n=e.dt,r,i,o=[],u;for(var a=0,f=t.length;a<f;a++){r=t[a];for(var l=a+1;l<f;l++)i=t[l],u=s(r,i),u&&o.push(u)}o.length&&this._world.emit(this.options.channel,{collisions:o})}}}),e});